/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025-2025. All rights reserved.
   MindEdge is licensed under Mulan PSL v2.
   You can use this software according to the terms and conditions of the Mulan PSL v2.
   You may obtain a copy of Mulan PSL v2 at:
            http://license.coscl.org.cn/MulanPSL2
   THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
   EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
   MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
   See the Mulan PSL v2 for more details.
 */
#include<fcntl.h>
#include<unistd.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<dirent.h>
#include"securec.h"
#include"cmscbb_cms_vrf.h"
#include"log_common.h"
#include"file_checker.h"

#define MAX_FILEPATH_LENGTH 512
#define MAX_CERT_DATA_LEN (10 * 1024 * 1024)

static CVB_BYTE pbRootCert0[] = {
    0x30, 0x82, 0x05, 0x4F, 0x30, 0x82, 0x03, 0x37, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x45,
    0xB6, 0x14, 0x73, 0x38, 0x30, 0xB4, 0x79, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
    0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30, 0x37, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
    0x06, 0x13, 0x02, 0x43, 0x4E, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x06,
    0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
    0x0E, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30,
    0x20, 0x17, 0x0D, 0x31, 0x35, 0x31, 0x30, 0x31, 0x35, 0x30, 0x38, 0x30, 0x38, 0x35, 0x30, 0x5A,
    0x18, 0x0F, 0x32, 0x30, 0x35, 0x30, 0x31, 0x30, 0x31, 0x35, 0x30, 0x38, 0x30, 0x38, 0x35, 0x30,
    0x5A, 0x30, 0x37, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4E,
    0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x06, 0x48, 0x75, 0x61, 0x77, 0x65,
    0x69, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0E, 0x48, 0x75, 0x61, 0x77,
    0x65, 0x69, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x82, 0x02, 0x22, 0x30, 0x0D,
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x02,
    0x0F, 0x00, 0x30, 0x82, 0x02, 0x0A, 0x02, 0x82, 0x02, 0x01, 0x00, 0xEE, 0x4C, 0x63, 0x03, 0x98,
    0x3B, 0xDD, 0x01, 0xFB, 0x9E, 0xFA, 0xD3, 0x23, 0xF6, 0x44, 0x24, 0xFD, 0x83, 0x6B, 0x74, 0x34,
    0x32, 0x0D, 0x34, 0xAB, 0xCF, 0xE6, 0x33, 0x90, 0xC0, 0x98, 0x59, 0x12, 0xE7, 0xFF, 0x6B, 0xBB,
    0x56, 0x50, 0x9C, 0xA5, 0xCD, 0xE7, 0x3A, 0x2A, 0xE7, 0x77, 0xB8, 0x7F, 0x5A, 0xFD, 0x79, 0x48,
    0x70, 0x8E, 0x86, 0xA4, 0x58, 0x83, 0xE3, 0xA1, 0x37, 0x42, 0xDB, 0xB8, 0x61, 0x06, 0x82, 0x9B,
    0x65, 0xB6, 0x4E, 0x0D, 0xB4, 0xBF, 0xB8, 0xF1, 0x6E, 0xF1, 0xA5, 0xEB, 0x70, 0x39, 0xC0, 0x9C,
    0x27, 0xBE, 0xD3, 0x60, 0xEC, 0x87, 0x90, 0xA5, 0x1E, 0x6F, 0x83, 0xA7, 0x7E, 0xE6, 0x21, 0xEE,
    0x7A, 0x36, 0x1C, 0x3F, 0x7C, 0xC5, 0x4E, 0xA9, 0x97, 0xF4, 0xD1, 0xC6, 0x38, 0x1B, 0x27, 0xC9,
    0x2B, 0x20, 0x51, 0x0B, 0x57, 0x1D, 0x79, 0xC8, 0x35, 0x8B, 0x69, 0x82, 0x02, 0x92, 0xC1, 0x7B,
    0xD5, 0x99, 0x87, 0x8F, 0xF1, 0x96, 0x69, 0xA1, 0x0A, 0xEA, 0xE4, 0x97, 0xA4, 0x72, 0x5A, 0xB5,
    0xEA, 0xCF, 0xA5, 0xE6, 0x8B, 0xD8, 0x25, 0x66, 0x19, 0x51, 0xEB, 0xB8, 0x34, 0x63, 0x40, 0x94,
    0xAA, 0xD4, 0xEF, 0xCA, 0xFF, 0x86, 0xA0, 0x9C, 0x93, 0xB8, 0x7D, 0x33, 0xAB, 0x50, 0xD4, 0x87,
    0xA5, 0x51, 0x6A, 0x62, 0xA4, 0x9A, 0x81, 0xC0, 0x30, 0xAA, 0x43, 0x80, 0x37, 0xE6, 0x16, 0x41,
    0xF7, 0xDD, 0x41, 0x70, 0x81, 0x4D, 0x97, 0xFD, 0xE7, 0xFA, 0x98, 0x91, 0xA9, 0x62, 0xC1, 0xEE,
    0x8E, 0x57, 0x2F, 0xA2, 0x7E, 0x4D, 0x64, 0xA0, 0x18, 0x04, 0x79, 0x8E, 0xA1, 0xFD, 0x9E, 0xF6,
    0x6C, 0x43, 0xC8, 0x86, 0x47, 0xD2, 0x66, 0x67, 0x0E, 0xC9, 0xDE, 0x30, 0x5E, 0x44, 0x0C, 0xAE,
    0x23, 0x3B, 0xEA, 0x81, 0x74, 0x59, 0xF9, 0x29, 0xD5, 0xF2, 0xF2, 0x53, 0x86, 0x89, 0x55, 0x49,
    0x69, 0xE1, 0xAD, 0xBB, 0x1D, 0xF3, 0x1B, 0xF2, 0xE0, 0x19, 0xF8, 0xA5, 0xEB, 0xCF, 0x35, 0x9B,
    0x29, 0x63, 0xDE, 0x31, 0xEC, 0xCF, 0x24, 0xF4, 0x0B, 0x22, 0x11, 0xA1, 0x09, 0xFD, 0x1F, 0x00,
    0xF9, 0x3E, 0x7E, 0x8F, 0xBA, 0x79, 0x29, 0xE4, 0x17, 0x32, 0x59, 0xDC, 0xDD, 0x67, 0x54, 0xC5,
    0x70, 0x12, 0xAE, 0x21, 0x63, 0x86, 0x52, 0x16, 0xF3, 0x70, 0x5A, 0x17, 0x9E, 0x4C, 0xB3, 0xEA,
    0x20, 0xDE, 0xE2, 0x0C, 0x6D, 0x1F, 0x80, 0xF7, 0x65, 0x0D, 0xF1, 0xD2, 0x5A, 0x71, 0x20, 0x77,
    0x96, 0x53, 0x12, 0xA5, 0xD4, 0x7D, 0x05, 0x7A, 0x81, 0x09, 0xC7, 0xA3, 0xCB, 0xD0, 0xAA, 0x1C,
    0xFE, 0x22, 0x7E, 0x78, 0xC4, 0xB3, 0xA3, 0x11, 0xF1, 0xE0, 0x9E, 0x42, 0xC9, 0x36, 0x20, 0x17,
    0xDF, 0x73, 0xA5, 0xF4, 0xBB, 0x9D, 0x85, 0xEC, 0x46, 0x1A, 0xFC, 0xCB, 0x56, 0xAC, 0x5D, 0xCA,
    0x7B, 0xB9, 0xB2, 0xE8, 0x23, 0xCC, 0x8B, 0x90, 0xC6, 0xC1, 0x62, 0xB8, 0x3E, 0x5C, 0x52, 0xF4,
    0xDE, 0x03, 0x87, 0x9A, 0x4B, 0x6D, 0x75, 0x7E, 0xBB, 0xC4, 0xA9, 0xC2, 0xC5, 0xCA, 0x58, 0x15,
    0x55, 0xAC, 0xFA, 0x73, 0xF0, 0xCA, 0xF3, 0x82, 0x9B, 0xCD, 0x52, 0x1F, 0x56, 0x18, 0x9C, 0x99,
    0xC6, 0x3F, 0x97, 0x2C, 0x8C, 0x7F, 0x21, 0x1F, 0x6C, 0x5B, 0x66, 0x93, 0x29, 0xC2, 0xB0, 0x99,
    0x9F, 0xA9, 0x59, 0x7F, 0xBB, 0x73, 0x69, 0xF9, 0x9E, 0xCC, 0x58, 0x09, 0xE9, 0xFF, 0xC0, 0xF0,
    0xD6, 0x4F, 0x9B, 0x38, 0x57, 0x7B, 0xE2, 0xD7, 0x81, 0xF5, 0x9A, 0x88, 0x4D, 0xDD, 0x05, 0x33,
    0xC5, 0xCB, 0xAB, 0x9B, 0xCC, 0x12, 0xA5, 0x59, 0x3E, 0x77, 0x05, 0x0A, 0x4F, 0xE2, 0xED, 0x75,
    0x62, 0xF7, 0x55, 0xC4, 0xDC, 0x52, 0xC2, 0xB2, 0xA1, 0x13, 0x85, 0x02, 0x03, 0x01, 0x00, 0x01,
    0xA3, 0x5D, 0x30, 0x5B, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80,
    0x14, 0x72, 0x76, 0x96, 0xC3, 0x0F, 0x90, 0x9C, 0xD4, 0x55, 0xB8, 0xAE, 0x9B, 0x49, 0xEE, 0xF7,
    0xDF, 0x5C, 0xC9, 0x02, 0xB4, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x05, 0x30, 0x03,
    0x01, 0x01, 0xFF, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06,
    0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x72, 0x76, 0x96, 0xC3, 0x0F,
    0x90, 0x9C, 0xD4, 0x55, 0xB8, 0xAE, 0x9B, 0x49, 0xEE, 0xF7, 0xDF, 0x5C, 0xC9, 0x02, 0xB4, 0x30,
    0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x03, 0x82,
    0x02, 0x01, 0x00, 0x70, 0x57, 0x51, 0x04, 0xB0, 0xCA, 0xC4, 0x6A, 0xB0, 0xC4, 0xD2, 0x11, 0x2A,
    0x13, 0x20, 0x3F, 0x37, 0x46, 0x29, 0x05, 0xC5, 0x23, 0x35, 0x63, 0xBC, 0x52, 0x62, 0xD8, 0x59,
    0x2C, 0xC1, 0xA6, 0xFE, 0x1E, 0x3D, 0x73, 0x6D, 0x57, 0xA3, 0xD0, 0xF1, 0x1A, 0xC6, 0x36, 0xD8,
    0x5C, 0x8A, 0xC6, 0xB9, 0xEA, 0x76, 0xDB, 0xF8, 0xE7, 0xF0, 0x72, 0x53, 0xE9, 0x8A, 0x2D, 0x35,
    0x8F, 0xCF, 0x50, 0x54, 0x8E, 0x12, 0x95, 0x4F, 0x01, 0x14, 0x95, 0x32, 0x53, 0xF1, 0x48, 0x44,
    0x8B, 0x9D, 0x95, 0x25, 0xD6, 0x27, 0x30, 0x15, 0x25, 0xC8, 0xC7, 0x6A, 0xD5, 0x3A, 0x4A, 0xA8,
    0xBB, 0x39, 0xD1, 0x83, 0xA1, 0x93, 0x88, 0x93, 0x1D, 0x23, 0x9B, 0x22, 0x79, 0xAC, 0xAA, 0x18,
    0xA0, 0x28, 0xF8, 0x84, 0xE8, 0xD8, 0x1D, 0xE6, 0x09, 0x20, 0x5F, 0xC2, 0x10, 0x81, 0x7E, 0x3A,
    0x76, 0x66, 0x8F, 0x93, 0xFA, 0x7B, 0xF3, 0x31, 0xC4, 0x2D, 0x05, 0xBC, 0x4C, 0x60, 0x26, 0xB2,
    0x72, 0xAA, 0x02, 0x06, 0x99, 0x14, 0x51, 0x92, 0x85, 0x44, 0x3B, 0x18, 0xE9, 0x20, 0x72, 0x2D,
    0x9C, 0x81, 0x5A, 0x11, 0xAE, 0xF2, 0xF1, 0xC5, 0xFD, 0xC2, 0x7B, 0xE3, 0x85, 0x82, 0x02, 0x47,
    0xA0, 0x91, 0x9A, 0x6D, 0x23, 0xCC, 0xDB, 0x1F, 0x77, 0x49, 0x70, 0x76, 0xD3, 0x9E, 0x76, 0x58,
    0x77, 0x17, 0xB9, 0xC8, 0x93, 0xC3, 0xAD, 0xD6, 0x9D, 0xF0, 0x50, 0xC2, 0xA0, 0xD4, 0x77, 0x0C,
    0x73, 0x1C, 0xF2, 0x81, 0x6B, 0xF8, 0x0A, 0x35, 0x53, 0x67, 0x2E, 0x84, 0xD7, 0xFF, 0xAC, 0xE8,
    0xA4, 0xC4, 0x1B, 0x05, 0xF4, 0xA7, 0xFD, 0x88, 0x48, 0x98, 0x5F, 0x8E, 0xD9, 0x51, 0x13, 0x3B,
    0xD0, 0xEA, 0x67, 0xF0, 0x04, 0xF6, 0xC8, 0xE8, 0xD6, 0x66, 0x0F, 0x4C, 0xA6, 0x46, 0xCC, 0xBB,
    0x9A, 0x51, 0x04, 0x3E, 0x79, 0x30, 0x7A, 0x81, 0x05, 0x37, 0xDC, 0xBC, 0x3F, 0xC1, 0x88, 0x4E,
    0xEA, 0x65, 0xDB, 0x49, 0xF9, 0x0B, 0xF4, 0x43, 0xF0, 0x9F, 0x88, 0xDC, 0x00, 0x72, 0xB1, 0x6E,
    0x09, 0xE7, 0xB1, 0x58, 0xEA, 0x6A, 0x09, 0x6B, 0x08, 0xD8, 0xBE, 0x9A, 0x86, 0x42, 0x2F, 0x91,
    0xE2, 0xF8, 0x89, 0xDD, 0x05, 0xB2, 0x5B, 0xE0, 0x32, 0x30, 0xEF, 0x21, 0x42, 0x29, 0xBD, 0xDB,
    0x8B, 0x86, 0x36, 0xEC, 0x62, 0x8F, 0xC0, 0x2F, 0x9D, 0xAD, 0x8A, 0xE4, 0xC7, 0x38, 0x4D, 0xBF,
    0xC7, 0x8D, 0x20, 0x4C, 0x27, 0xD8, 0x25, 0xB1, 0xF4, 0xCB, 0x36, 0xA3, 0x74, 0xC4, 0x34, 0xFB,
    0x6F, 0xBF, 0xF8, 0xA3, 0x61, 0x64, 0x93, 0x94, 0xB3, 0xB7, 0xFA, 0xCA, 0x4E, 0x24, 0x95, 0x55,
    0xB1, 0xF6, 0xD9, 0x44, 0xB6, 0xAE, 0x2E, 0x52, 0x57, 0xC0, 0x3E, 0x81, 0xB1, 0xFF, 0xE3, 0x53,
    0x63, 0x14, 0xD6, 0x65, 0x03, 0x1B, 0x31, 0x2D, 0x23, 0x74, 0x80, 0x77, 0x92, 0xB4, 0x38, 0xA1,
    0x90, 0x5B, 0x3D, 0x96, 0x26, 0x90, 0x20, 0x22, 0x98, 0xA4, 0x94, 0xE8, 0x64, 0xA1, 0xD2, 0xEA,
    0x13, 0xF4, 0xA5, 0xA6, 0x14, 0xEB, 0x5C, 0x12, 0xAB, 0x2E, 0x25, 0x50, 0x4C, 0xA4, 0x6B, 0x92,
};

/* 根证书第二部分，用宏定义 */
#define ROOT_CERT_PART2 { \
    0xB3, 0x41, 0x92, 0x2B, 0xEE, 0x1F, 0xC1, 0x67, 0xC7, 0xA5, 0x54, 0x8E, 0xB1, 0x18, 0xA1, 0xE0, \
    0xBF, 0x65, 0x52, 0xA6, 0x06, 0x0A, 0xBB, 0x10, 0xB9, 0xF4, 0x8F, 0xAC, 0xC9, 0x74, 0x6C, 0x37, \
    0xA0, 0x2C, 0x95, 0x54, 0x6A, 0xF3, 0xFD, 0x99, 0xA3, 0x52, 0x0F, 0x71, 0x4D, 0xE4, 0xD3, 0x55, \
    0x6C, 0x64, 0x09, 0x6F, 0x01, 0x1A, 0xF1, 0x4B, 0xE9, 0x58, 0x7F, 0x3B, 0x5D, 0x8A, 0xCB, 0x34, \
    0x81, 0xD3, 0x68, 0x8C, 0x09, 0x83, 0x67, 0x09, 0x3B, 0xDD, 0x5C, 0x2D, 0xCB, 0x82, 0xAB, 0x3D, \
    0xA9, 0xC4, 0x87}

static CVB_BYTE pbRootG2Cert0[] = {
    0x30, 0x82, 0x06, 0x42, 0x30, 0x82, 0x03, 0xF6, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x03, 0x3C, 0x3A, 0xDB, 0x30,
    0x41, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0A, 0x30, 0x34, 0xA0, 0x0F, 0x30, 0x0D, 0x06,
    0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0xA1, 0x1C, 0x30, 0x1A, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x08, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04,
    0x02, 0x01, 0x05, 0x00, 0xA2, 0x03, 0x02, 0x01, 0x20, 0x30, 0x7C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
    0x06, 0x13, 0x02, 0x43, 0x4E, 0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x13, 0x48, 0x75, 0x61,
    0x77, 0x65, 0x69, 0x20, 0x54, 0x65, 0x63, 0x68, 0x6E, 0x6F, 0x6C, 0x6F, 0x67, 0x69, 0x65, 0x73, 0x31, 0x27, 0x30,
    0x25, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1E, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x43, 0x65, 0x72, 0x74,
    0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79,
    0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1D, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x49,
    0x6E, 0x74, 0x65, 0x67, 0x72, 0x69, 0x74, 0x79, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20,
    0x47, 0x32, 0x30, 0x20, 0x17, 0x0D, 0x32, 0x31, 0x30, 0x32, 0x30, 0x37, 0x30, 0x39, 0x33, 0x36, 0x34, 0x36, 0x5A,
    0x18, 0x0F, 0x32, 0x30, 0x35, 0x31, 0x30, 0x35, 0x30, 0x37, 0x30, 0x39, 0x33, 0x36, 0x34, 0x36, 0x5A, 0x30, 0x7C,
    0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4E, 0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03,
    0x55, 0x04, 0x0A, 0x13, 0x13, 0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x54, 0x65, 0x63, 0x68, 0x6E, 0x6F, 0x6C,
    0x6F, 0x67, 0x69, 0x65, 0x73, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1E, 0x48, 0x75, 0x61,
    0x77, 0x65, 0x69, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x41,
    0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1D,
    0x48, 0x75, 0x61, 0x77, 0x65, 0x69, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x67, 0x72, 0x69, 0x74, 0x79, 0x20, 0x52, 0x6F,
    0x6F, 0x74, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x82, 0x02, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x02, 0x0F, 0x00, 0x30, 0x82, 0x02, 0x0A,
    0x02, 0x82, 0x02, 0x01, 0x00, 0xDD, 0x89, 0x4F, 0x23, 0xFC, 0x75, 0x2D, 0xA6, 0x24, 0x8B, 0x8E, 0xC9, 0xAB, 0xD6,
    0xDD, 0x4F, 0xFE, 0x70, 0x43, 0x4D, 0xBC, 0x6E, 0xBA, 0x7D, 0x0E, 0x55, 0xC8, 0x9A, 0x43, 0xA3, 0x9C, 0xF8, 0x4E,
    0xB2, 0xD5, 0x85, 0xC2, 0x52, 0x61, 0x67, 0xFA, 0x9D, 0x56, 0xC0, 0xA1, 0x09, 0x41, 0xEB, 0x64, 0x29, 0xB0, 0x96,
    0x95, 0xC6, 0x5C, 0x87, 0xC2, 0x36, 0x1B, 0xF7, 0xFC, 0xE8, 0x9F, 0xD9, 0xE2, 0x6E, 0x19, 0xC1, 0x92, 0x52, 0x57,
    0x4E, 0x01, 0xFE, 0xE2, 0x90, 0x18, 0x0C, 0xB7, 0xE4, 0x55, 0xB9, 0x6C, 0xD0, 0x6D, 0xBD, 0x81, 0xF7, 0xC4, 0xDE,
    0x27, 0x7B, 0x4A, 0x06, 0x5B, 0xAA, 0x96, 0x92, 0x02, 0x50, 0xB0, 0x31, 0xC6, 0xEA, 0x21, 0x59, 0xA9, 0x10, 0x4A,
    0x2F, 0x1D, 0x4E, 0xEF, 0x23, 0xA1, 0xC2, 0xF1, 0x1D, 0x1B, 0x98, 0xDF, 0x27, 0x08, 0x36, 0xE8, 0xD2, 0xB9, 0x69,
    0xDE, 0xF9, 0xBC, 0xCE, 0x8B, 0x1C, 0x0E, 0xAD, 0x10, 0xF1, 0xBD, 0xB6, 0xD3, 0x21, 0x72, 0x68, 0xFD, 0x56, 0x0C,
    0xD4, 0x74, 0x01, 0x4E, 0x1C, 0xEB, 0x75, 0x22, 0x50, 0x24, 0x67, 0xEA, 0x1D, 0x16, 0x7E, 0x8F, 0xAE, 0xD7, 0xB8,
    0x8B, 0xF3, 0x34, 0x6D, 0x86, 0x60, 0x0F, 0xF2, 0xD2, 0x86, 0x58, 0x2D, 0x06, 0x9F, 0xA2, 0x0E, 0xB5, 0x83, 0xFB,
    0x31, 0xDF, 0x71, 0x60, 0x03, 0x10, 0x61, 0x2C, 0x13, 0x3C, 0x72, 0x5F, 0xB0, 0x89, 0xBE, 0x22, 0x41, 0x4E, 0x7A,
    0x14, 0xC0, 0xA3, 0x34, 0xFC, 0x24, 0x06, 0x2F, 0x36, 0x94, 0x4D, 0xC1, 0x8A, 0x7E, 0x65, 0x51, 0xAA, 0xF9, 0x71,
    0x0A, 0xE4, 0x86, 0x45, 0x8B, 0x19, 0x5A, 0x53, 0xB2, 0xA0, 0x6A, 0x26, 0x89, 0x2C, 0xE6, 0x1F, 0x10, 0x8C, 0x2B,
    0x3B, 0x21, 0xAC, 0x75, 0xBE, 0x45, 0x33, 0xBA, 0x62, 0x27, 0x45, 0xBD, 0xBB, 0x7F, 0x78, 0xA3, 0x34, 0x4D, 0x19,
    0x77, 0xB1, 0x79, 0xBA, 0x4B, 0x5F, 0x82, 0xF8, 0x54, 0x58, 0xDB, 0x97, 0xAC, 0xE2, 0x5A, 0xD7, 0x06, 0x6D, 0x7F,
    0xED, 0x52, 0x1C, 0x63, 0x2F, 0x02, 0x02, 0x60, 0x40, 0xCD, 0x8B, 0x1C, 0x16, 0x46, 0x89, 0xA8, 0x38, 0x8E, 0xA9,
    0x9D, 0xB0, 0x1F, 0x79, 0xC3, 0x9A, 0x89, 0xD9, 0x78, 0xB8, 0x0B, 0xD2, 0x07, 0xE1, 0x48, 0xDE, 0x57, 0xA1, 0xFB,
    0x0E, 0x6B, 0x7F, 0x8A, 0xD0, 0x5C, 0x0B, 0x18, 0xC4, 0xAC, 0xF1, 0x2E, 0xB3, 0x9D, 0x2C, 0x85, 0x76, 0x68, 0x2C,
    0x74, 0x0B, 0xB9, 0xDC, 0x4C, 0xD0, 0x43, 0xF0, 0x83, 0xA2, 0x5C, 0x83, 0x2B, 0x36, 0xB7, 0xF2, 0xCA, 0x91, 0x33,
    0x16, 0xB6, 0x15, 0x2B, 0xC8, 0xAD, 0xB8, 0xE2, 0x97, 0x2A, 0x6E, 0x52, 0x0E, 0x90, 0x1F, 0x8A, 0x7C, 0x5D, 0x97,
    0x4B, 0x69, 0xCF, 0xC3, 0xEB, 0x7B, 0x3A, 0xF6, 0xB5, 0x5B, 0x0E, 0x07, 0x2D, 0xF5, 0x8B, 0x77, 0xF5, 0xEE, 0xCF,
    0x0B, 0x1E, 0x75, 0x5C, 0xB9, 0x10, 0x65, 0xEB, 0xF3, 0x5B, 0x4C, 0x1A, 0x72, 0xEC, 0xA5, 0xBF, 0x3C, 0x96, 0x4C,
    0x21, 0xEA, 0xBC, 0xD1, 0xE8, 0xDF, 0x35, 0x4B, 0xBD, 0xF8, 0x6D, 0x7C, 0x1E, 0xF4, 0x2E, 0x48, 0x53, 0x4E, 0x76,
    0x48, 0x70, 0x91, 0x52, 0x8B, 0xF4, 0x33, 0xEB, 0x60, 0x5F, 0x43, 0x00, 0x6B, 0x88, 0xC2, 0xC4, 0xB4, 0xD6, 0x85,
    0x0F, 0x25, 0x40, 0xD7, 0xF6, 0x72, 0x24, 0xB3, 0xDA, 0x3B, 0x43, 0x6F, 0x43, 0xB4, 0xF6, 0xB6, 0x49, 0x1F, 0xB2,
    0x8A, 0x52, 0x8C, 0x6A, 0xBC, 0x53, 0xD6, 0xDC, 0x8A, 0xB2, 0xCB, 0xC8, 0x82, 0x53, 0xDC, 0xF5, 0xB9, 0x8F, 0xEC,
    0xEB, 0xF7, 0xA7, 0x0E, 0xE2, 0x79, 0xCE, 0xE9, 0x32, 0xB6, 0x7A, 0xC5, 0xE7, 0x04, 0x2E, 0xA6, 0xFE, 0xDA, 0xAB,
    0x36, 0x12, 0xA7, 0x43, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x63, 0x30, 0x61, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D,
    0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01,
    0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14,
    0x0E, 0x39, 0x01, 0x7D, 0x26, 0xCB, 0x02, 0x6A, 0xE0, 0xCA, 0x34, 0x65, 0x50, 0x20, 0xA1, 0x44, 0x6C, 0xEC, 0x7F,
    0x9E, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x0E, 0x39, 0x01, 0x7D, 0x26,
    0xCB, 0x02, 0x6A, 0xE0, 0xCA, 0x34, 0x65, 0x50, 0x20, 0xA1, 0x44, 0x6C, 0xEC, 0x7F, 0x9E, 0x30, 0x41, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0A, 0x30, 0x34, 0xA0, 0x0F, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86,
    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0xA1, 0x1C, 0x30, 0x1A, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
    0xF7, 0x0D, 0x01, 0x01, 0x08, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
    0x00, 0xA2, 0x03, 0x02, 0x01, 0x20, 0x03, 0x82, 0x02, 0x01, 0x00, 0x61, 0x9D, 0xA9, 0xE9, 0x54, 0xEC, 0xF4, 0x7B,
    0x17, 0x45, 0x7D, 0x2C, 0xAF, 0xF1, 0x5C, 0x41, 0x64, 0xA2, 0xF4, 0x5C, 0x86, 0x03, 0xB9, 0xEE, 0x67, 0x99, 0xEA,
    0x34, 0x08, 0x9D, 0xBB, 0xEF, 0x44, 0xE3, 0xE8, 0xD6, 0x5A, 0xC0, 0xE2, 0x4F, 0x90, 0xE0, 0x25, 0xBB, 0x34, 0x80,
    0x26, 0x91, 0x8A, 0x65, 0xD6, 0x60, 0x4D, 0xF6, 0x5D, 0x8C, 0xA8, 0x11, 0x52, 0x61, 0x80, 0xCC, 0xBD, 0x08, 0x05,
    0xD3, 0x9F, 0xDA, 0x56, 0xE6, 0x47, 0x2C, 0xF8, 0x42, 0x6D, 0x5E, 0xEA, 0x74, 0xEA, 0x07, 0xA4, 0xEF, 0xBD, 0xEC,
    0x9E, 0x92, 0xC9, 0xF1, 0x7F, 0x10, 0xC0, 0x42, 0xAD, 0x2D, 0xDB, 0x36, 0xC8, 0xBF, 0x8D, 0x4E, 0x4B, 0x74, 0x4E,
    0x6D, 0xFE, 0x42, 0x4F, 0x9E, 0x93, 0x29, 0x1E, 0xE6, 0xA7, 0xBB, 0x7A, 0x41, 0x1F, 0x37, 0x12, 0xBF, 0x33, 0x68,
    0xAF, 0x16, 0x6D, 0xE8, 0x45, 0x33, 0x1D, 0x29, 0xB9, 0x14, 0xED, 0xFA, 0x44, 0x93, 0xED, 0xBD, 0xF6, 0x37, 0x3A,
    0x76, 0x8C, 0x8E, 0xE3, 0xC6, 0x5B, 0xA0, 0x8B, 0xBF, 0xBF, 0xA0, 0x9A, 0x11, 0x77, 0x06, 0x1D, 0xEC, 0xD2, 0x93,
    0x76, 0x4A, 0x63, 0x2D, 0x20, 0x73, 0xDD, 0xD7, 0xE2, 0x82, 0xDD, 0x86, 0xA7, 0xC5, 0x39, 0x05, 0x35, 0xF1, 0x02,
    0xF3, 0xBA, 0x86, 0xC5, 0x64, 0x6F, 0x83, 0x87, 0x6C, 0x9E, 0x67, 0xFA, 0x1E, 0x5A, 0xBD, 0x8F, 0x2A, 0xFC, 0x7C,
    0xF3, 0x77, 0x6C, 0x5C, 0xED, 0xB2, 0x45, 0x1D, 0x5C, 0xB9, 0xA4, 0xBE, 0x27, 0x87, 0xFB, 0xCC, 0xD7, 0x3F, 0x3F,
    0x31, 0x16, 0x54, 0xA7, 0x11, 0x8B, 0x28, 0xEA, 0x33, 0x35, 0xAA, 0xD8, 0x11, 0x25, 0x52, 0xCC, 0x86, 0x5C, 0xF6,
    0x8B, 0xC0, 0xD3, 0xC5, 0x8A, 0x99, 0xA4, 0xAA, 0x5E, 0x40, 0xA0, 0x37, 0x01, 0x2F, 0xEC, 0xAF, 0xDC, 0x0C, 0x29,
    0xCA, 0x02, 0x9E, 0xF7, 0x6A, 0x49, 0xD4, 0x00, 0x62, 0x60, 0xEB, 0x30, 0x0D, 0xDC, 0x16, 0x62, 0x91, 0x22, 0xD8,
    0x33, 0xE5, 0x7E, 0x4E, 0x67, 0x38, 0x15, 0x1F, 0xD4, 0x40, 0x6F, 0xFE, 0x19, 0x29, 0x1D, 0xBE, 0x0D, 0x24, 0x9B,
    0x12, 0xAD, 0xDE, 0x2C, 0xF0, 0xA1, 0x57, 0x2D, 0x8F, 0xF2, 0x5E, 0xDF, 0x9D, 0x15, 0x40, 0xB3, 0xA0, 0x62, 0x49,
    0x8E, 0x4D, 0x05, 0xDD, 0x04, 0x2B, 0x4C, 0xA3, 0xC4, 0xF9, 0xAB, 0xF6, 0x56, 0xAB, 0xC9, 0x9C, 0xB7, 0x50, 0xED,
    0x4B, 0x82, 0x9A, 0x2F, 0x18, 0x0B, 0x41, 0x03, 0x76, 0xD7, 0x84, 0x12, 0xE4, 0xCA, 0x98, 0xEB, 0xC9, 0x85, 0xCA,
    0xE5, 0x37, 0x78, 0xA3, 0x7B, 0xB0, 0x3E, 0xC1, 0x53, 0x38, 0x46, 0xEA, 0xDF, 0xA9, 0x85, 0x58, 0x45, 0x27, 0xA9,
    0xAC, 0x94, 0xF3, 0xA9, 0x6B, 0x13, 0x92, 0x69, 0x41, 0x70, 0x05, 0x75, 0xB5, 0x9D, 0x9E, 0x1A, 0x7E, 0x82, 0xAB,
    0x93, 0xB1, 0x05, 0x5D, 0x54, 0x35, 0xC6, 0xBD, 0xFB, 0x16, 0xC7, 0x3E, 0x6B, 0x63, 0xFB, 0x0C, 0x5F, 0x46, 0x0F,
    0x89, 0x62, 0xCB, 0x32, 0xDC, 0xFB, 0x4C, 0x4E, 0x25, 0x94, 0x55, 0xAC, 0xCE, 0xDF, 0x34, 0xF6, 0xDD, 0x20, 0x3D,
};

/* G2根证书第二部分，用宏定义 */
#define ROOT_G2_CERT_PART2                                                                                          \
    {                                                                                                               \
        0x1A, 0xDA, 0x0A, 0x7A, 0xE6, 0xAC, 0x93, 0x2B, 0x8C, 0x2B, 0x0F, 0xFC, 0x6C, 0x4B, 0xB7, 0x3A, 0x36, 0xD0, \
            0x0F, 0xBE, 0x5F, 0x12, 0x5F, 0xF1, 0xFB, 0xEB, 0x25, 0x7B, 0xFD, 0x71, 0x6D, 0xAA, 0x69, 0x9F, 0x46,   \
            0x3D, 0xD8, 0xC8, 0x68, 0xF6, 0x0D, 0xCB, 0x56, 0x67, 0xCA, 0x94, 0x55, 0x3B, 0x31, 0x1D, 0x0C, 0x55,   \
            0x31, 0x69, 0x1E, 0x17, 0x37, 0xFB, 0x1B, 0x86, 0xAE, 0xEA, 0x3A, 0xA7, 0x50, 0x2A, 0xD9, 0xC7, 0x0C,   \
            0x24, 0xAD, 0xB3, 0xCC, 0xDC, 0x7E, 0x8B, 0x03, 0x75, 0x5D, 0xAC, 0x5D, 0x68, 0x58, 0xDD, 0x21, 0x8E    \
    }

#define PERMISSION_CRL 0640
#define PERMISSION_HWSIPCRL 0750
#define PERMISSION_750 (S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP)
#define CRL_MAX_SIZE 32768
#define ROOT_UID 0
#define CRL_PATH_G1 "/etc/hwsipcrl/ascendsip.crl"
#define CRL_PATH_G2 "/etc/hwsipcrl/ascendsip_g2.crl"
#define CRL_SAVE_PATH "/etc/hwsipcrl/"

#ifndef UPDATE_OK
#define UPDATE_OK 1
#endif

static int IsValidPath(const char *fileName)
{
    return access(fileName, W_OK);
}

static int CheckSaveCrlPathPermission(const char *dirName)
{
    struct stat dirStat;

    if (stat(dirName, &dirStat) != 0) {
        OM_LOG_INFO("dir %s stat error.", dirName);
        return -1;
    }

    if ((dirStat.st_uid) != ROOT_UID) {
        OM_LOG_INFO("dir %s owner is not root.", dirName);
        return -1;
    }

    if ((dirStat.st_mode & 0x1ff) != PERMISSION_750 && (chmod(dirName, PERMISSION_HWSIPCRL) != 0)) {
        OM_LOG_INFO("change dir %s permission to 750 fail.", dirName);
        return -1;
    }

    return 0;
}

static int CheckAndChangeCrlPermission(const char *crlPath)
{
    struct stat crlPathStat;

    if (stat(crlPath, &crlPathStat) != 0) {
        OM_LOG_INFO("dir %s stat error.", crlPath);
        return -1;
    }

    if ((crlPathStat.st_uid) != ROOT_UID) {
        OM_LOG_INFO("dir %s owner is not root.", crlPath);
        return -1;
    }

    if ((crlPathStat.st_mode != PERMISSION_CRL) && (chmod(crlPath, PERMISSION_CRL) != 0)) {
        OM_LOG_INFO("chmod path %s permission to 640 fail.", crlPath);
        return -1;
    }

    return 0;
}

static int CopyCrlToSavePath(const char *updateCrl, const char *desFile)
{
    FILE *fpbr = NULL;
    FILE *fpbw = NULL;
    char ch;

    if ((updateCrl == NULL) || (desFile == NULL)) {
        OM_LOG_ERROR("inputs invalid!");
        return -1;
    }

    fpbr = safety_fopen(updateCrl, "rb");
    if (fpbr == NULL) {
        OM_LOG_INFO("fopen updateCrl fail!");
        return -1;
    }

    fpbw = safety_fopen(desFile, "wb");
    if (fpbw == NULL) {
        OM_LOG_INFO("fopen updateCrl fail!");
        (void)fclose(fpbr);
        return -1;
    }

    while (fread(&ch, sizeof(char), 1, fpbr) != 0) {
        (void)fwrite(&ch, sizeof(char), 1, fpbw);
    }

    (void)fclose(fpbr);
    (void)fclose(fpbw);

    if (CheckAndChangeCrlPermission(desFile) != 0) {
        return -1;
    }

    OM_LOG_INFO("Update crl file success!");
    return 0;
}

static int CreateCrlSavePath(const char *dirName)
{
    struct stat crlSavePathStat;

    if (mkdir(dirName, PERMISSION_HWSIPCRL) != 0) {
        OM_LOG_INFO("mkdir dir fail!");
        return -1;
    }

    if (chmod(dirName, PERMISSION_HWSIPCRL) != 0) {
        OM_LOG_INFO("chmod dir fail!");
        return -1;
    }

    OM_LOG_INFO("create dir!");

    if (stat(dirName, &crlSavePathStat) != 0) {
        OM_LOG_INFO("stat dir fail!");
        return -1;
    }
    if ((crlSavePathStat.st_mode & 0x1ff) == PERMISSION_750) {
        return 0;
    }

    OM_LOG_INFO("dir permission is incorrect!");
    return -1;
}

static int ChkSysLocalCrl(const char *updateCrl, const char *localCrl)
{
    /* 检查默认crl路径是否存在, 若不存在则进行创建 */
    if ((IsValidPath(CRL_SAVE_PATH) != 0) && (CreateCrlSavePath(CRL_SAVE_PATH) != 0)) {
        OM_LOG_ERROR("ChkSysLocalCrl creatre crl path failed.");
        return -1;
    }

    /* 文件夹存在,检查文件夹属主和权限 */
    if (CheckSaveCrlPathPermission(CRL_SAVE_PATH) != 0) {
        OM_LOG_ERROR("crl path permission error.");
        return -1;
    }

    /* 检查默认crl文件是否存在, 若不存在或者大小为0, 则使用用户输入CRL进行创建 */
    if ((IsValidPath(localCrl) != 0) || (get_file_size(localCrl) == 0)) {
        if (CopyCrlToSavePath(updateCrl, localCrl) == 0) {
            OM_LOG_INFO("System local CRL file not exist, use input CRL to create success.");
            return UPDATE_OK;
        }

        if (unlink(localCrl) != 0) {
            OM_LOG_ERROR("Unlink local crl path failed.");
        }

        OM_LOG_ERROR("Copy Crl To SavePath failed.");
        return -1;
    }

    if (CheckAndChangeCrlPermission(localCrl) != 0) {
        return -1;
    }

    return 0;
}

static int ChkFileSize(const char *filePath)
{
    struct stat crlStat;

    if (stat(filePath, &crlStat) != 0) {
        OM_LOG_INFO("stat %s fail!", filePath);
        return -1;
    }
    if (crlStat.st_size >= CRL_MAX_SIZE) {
        OM_LOG_INFO("The crl file size(%ld) is too large!", crlStat.st_size);
        return -1;
    }

    return 0;
}

static int GetCrlCertInfo(const CVB_BYTE *crlData, CVB_UINT32 crlLen, char* localCrl)
{
    CMSCBB_ERROR_CODE cms_ret = 0;  /* 接口调用返回值 */
    int ret = 0;
    CmscbbCrlCertInfoList* crlInfoList = CVB_NULL;  /* 解析信息的返回值 */
    /* 参数检查 */
    if (crlData == NULL) {
        return -1;
    }

    /* 解析crl基本信息 */
    cms_ret = CmscbbDecodeCrlCertInfoToList(crlData, crlLen, &crlInfoList);
    if (cms_ret != CVB_SUCCESS) {
        OM_LOG_ERROR("decode crl info failed, cms_ret:%X", cms_ret);
        CmscbbCrlCertInfoListFree(crlInfoList);
        crlInfoList = NULL;
        return -1;
    }

    if (crlInfoList->certCount > 0) {
        switch (crlInfoList->certInfoList[0]->algorithm) {
            // g1
            case CMSCBB_ENC_RSA:
            case CMSCBB_ENC_SHA256WITHRSAENCRYPTION:
            case CMSCBB_ENC_SHA384WITHRSAENCRYPTION:
            case CMSCBB_ENC_SHA512WITHRSAENCRYPTION:
                if (strcpy_s(localCrl, MAX_FILEPATH_LENGTH, CRL_PATH_G1) != 0) {
                    OM_LOG_ERROR("copy g1 crl faild!");
                    CmscbbCrlCertInfoListFree(crlInfoList);
                    crlInfoList = NULL;
                    return -1;
                }
                OM_LOG_INFO("crl signatureAlgorithm: G1");
                break;
            // g2
            case CMSCBB_ENC_RSA_PSS:
                if (strcpy_s(localCrl, MAX_FILEPATH_LENGTH, CRL_PATH_G2) != 0) {
                    OM_LOG_ERROR("copy g2 crl faild!");
                    CmscbbCrlCertInfoListFree(crlInfoList);
                    crlInfoList = NULL;
                    return -1;
                }
                OM_LOG_INFO("crl signatureAlgorithm: G2");
                break;
            default:
                OM_LOG_ERROR("crl signatureAlgorithm is wrong!");
                ret = -1;
                break;
        }
    }

    CmscbbCrlCertInfoListFree(crlInfoList);
    crlInfoList = NULL;
    return ret;
}

static int GetLocalCrlFromUptCrl(const char *updateCrl, char* localCrl)
{
    long crl_size = get_file_size(updateCrl);
    if ((crl_size <= 0) || (crl_size > MAX_CERT_DATA_LEN)) {
        OM_LOG_ERROR("get faile size failed, crl_size=%ld", crl_size);
        return -1;
    }
    size_t fileBytes = (size_t)crl_size;

    FILE *pf = safety_fopen(updateCrl, "rb");
    if (pf == NULL) {
        OM_LOG_ERROR("open updateCrl error");
        return -1;
    }

    char *data = (char *)malloc(fileBytes + 1);
    if (data == NULL) {
        OM_LOG_ERROR("malloc crl file memory error!");
        (void)fclose(pf);
        return -1;
    }

    if (memset_s(data, fileBytes + 1, 0, fileBytes + 1) != 0) {
        OM_LOG_ERROR("memset_s crl buffer error!");
        (void)fclose(pf);
        free(data);
        data = NULL;
        return -1;
    }

    size_t readLen = fread(data, 1, fileBytes, pf);
    if (readLen != fileBytes) {
        OM_LOG_ERROR("fread error");
        (void)fclose(pf);
        free(data);
        data = NULL;
        return -1;
    }

    int ret = GetCrlCertInfo((const CVB_BYTE *)data, (CVB_UINT32)fileBytes, localCrl);

    (void)fclose(pf);
    free(data);
    data = NULL;
    return ret;
}

static int ChkUsrInputCrl(const char *updateCrl)
{
    CMSCBB_ERROR_CODE ret = -1;
    CMSCBB_VRF_CTX vrf_ctx = NULL;              /* 解析updatePathCrl的上下文 */
    CmscbbCrlBundleInfo *pResult = NULL;        /* CRL解析结果 */
    CmscbbCtxCreateParams createParams = { 0 }; /* 回调函数注册 */
    CVB_BYTE *pbRoot = NULL;                  /* 证书汇总 */
    size_t nRoot;                     /* 证书总字节数 */
    CVB_BYTE pbRootCert2[] = ROOT_CERT_PART2; /* 证书局部数据 */

    if ((ChkFileSize(updateCrl)) != 0) {
        OM_LOG_INFO("ChkFileSize %s fail!", updateCrl);
        return -1;
    }

    createParams.st_size = sizeof(createParams);

    /* 为解析updateCrl创建上下文 */
    if ((ret = CmscbbVerifyCreateCtx(&vrf_ctx, &createParams)) != CVB_SUCCESS) {
        OM_LOG_INFO("CmscbbVerifyCreateCtx failed(%u).", ret);
        return -1;
    }

    /* 组合根证书 */
    nRoot = sizeof(pbRootCert0) + sizeof(pbRootCert2);
    pbRoot = (CVB_BYTE *)malloc(nRoot);
    if (pbRoot == NULL) {
        OM_LOG_INFO("Initialize root certificate failed.");
        CmscbbVrfCtxFree(vrf_ctx);
        return -1;
    }

    if ((memcpy_s(pbRoot, nRoot, pbRootCert0, sizeof(pbRootCert0)) != 0) ||
        (memcpy_s(pbRoot + sizeof(pbRootCert0), nRoot - sizeof(pbRootCert0), pbRootCert2, sizeof(pbRootCert2)) != 0)) {
        CmscbbVrfCtxFree(vrf_ctx);
        free(pbRoot);
        pbRoot = NULL;
        OM_LOG_ERROR("Memcpy_s failed.");
        return -1;
    }

    /* 加入根证书 */
    if ((ret = CmscbbVerifyAddCert(vrf_ctx, (const CVB_BYTE *)pbRoot, nRoot)) != CVB_SUCCESS) {
        CmscbbVrfCtxFree(vrf_ctx);
        free(pbRoot);
        pbRoot = NULL;
        OM_LOG_INFO("CmscbbVerifyAddCert failed(%u).", ret);
        return -1;
    }

    /* 解析updateCrl */
    if ((ret = CmscbbDecodeCrlFile(vrf_ctx, (const CVB_CHAR *)updateCrl, &pResult)) != CVB_SUCCESS) {
        CmscbbVrfCtxFree(vrf_ctx);
        free(pbRoot);
        pbRoot = NULL;
        OM_LOG_INFO("CmscbbDecodeCrl failed(%u).", ret);
        return -1;
    }

    CmscbbCrlFree(vrf_ctx, pResult);
    CmscbbVrfCtxFree(vrf_ctx);
    free(pbRoot);
    pbRoot = NULL;
    return 0;
}

static int GetCrlAndDecode(const char *Crl, CVB_BYTE *RootCert, size_t RootCertLen, CVB_BYTE *pbRootG2,
    size_t rootCertG2Size, CMSCBB_VRF_CTX *vrf_ctx, CmscbbCrlBundleInfo **DecodeCrl)
{
    CmscbbCtxCreateParams createParams = {0};  /* 回调函数注册 */
    createParams.st_size = sizeof(createParams);

    /* 为解析pszCrlToUpdate创建上下文 */
    if ((CmscbbVerifyCreateCtx(vrf_ctx, &createParams)) != CVB_SUCCESS) {
        OM_LOG_INFO("CmscbbVerifyCreateCtx fail.");
        return -1;
    }

    /* 加入根证书 */
    if ((CmscbbVerifyAddCert(*vrf_ctx, (const CVB_BYTE*)RootCert, RootCertLen)) != CVB_SUCCESS) {
        OM_LOG_ERROR("CmscbbVerifyAddCert fail.");
        CmscbbVrfCtxFree(*vrf_ctx);
        return -1;
    }

    /* 添加G2 RSA_PSS根证书 */
    if (CmscbbVerifyAddCert(*vrf_ctx, (const CVB_BYTE*)pbRootG2, rootCertG2Size) != CVB_SUCCESS) {
        OM_LOG_ERROR("Add root G2 certificate failed.");
        CmscbbVrfCtxFree(*vrf_ctx);
        return -1;
    }

    /* 解析pszCrlToUpdate */
    if ((CmscbbDecodeCrlFile(*vrf_ctx, (const CVB_CHAR*)Crl, DecodeCrl)) != CVB_SUCCESS) {
        CmscbbVrfCtxFree(*vrf_ctx);
        OM_LOG_INFO("CmscbbDecodeCrl fail.");
        return -1;
    }
    return 0;
}

static CVB_BYTE *GetRootCerf(CVB_BYTE *pbRootCert, const CVB_UINT32 cert0Len,
                             CVB_BYTE *pbRootCert2, const CVB_UINT32 cert2Len)
{
    CVB_BYTE *pbRoot = CVB_NULL;
    CVB_UINT32 certLen = cert0Len + cert2Len;
    if ((certLen <= 0) || (certLen > MAX_CERT_DATA_LEN)) {
        OM_LOG_ERROR("invalid input cert0Len:%d  cert2Len:%d.", cert0Len, cert2Len);
        return CVB_NULL;
    }

    pbRoot = (CVB_BYTE *)malloc(certLen);
    if (pbRoot == CVB_NULL) {
        OM_LOG_ERROR("Initialize root certificate failed.");
        return CVB_NULL;
    }

    if (memcpy_s(pbRoot, certLen, pbRootCert, cert0Len) != 0) {
        free(pbRoot);
        pbRoot = CVB_NULL;
        OM_LOG_ERROR("memcpy pbRootCert to pbRoot is failed.");
        return CVB_NULL;
    }
    if (memcpy_s(pbRoot + cert0Len, cert2Len, pbRootCert2, cert2Len) != 0) {
        free(pbRoot);
        pbRoot = CVB_NULL;
        OM_LOG_ERROR("memcpy pbRootCert2 to pbRoot is failed.");
        return CVB_NULL;
    }

    return pbRoot;
}

static int DoCrlCompare(const char *updateCrl, const char *pCrlFileOnDevice, CmscbbCrlPeriodStat* stat)
{
    CMSCBB_VRF_CTX vrf_ctx1 = NULL; /* 解析updateCrl的上下文 */
    CMSCBB_VRF_CTX vrf_ctx2 = NULL; /* 解析pszCrlOnDevice的上下文 */
    CmscbbCrlBundleInfo* pCrlToUpdate = NULL;  /* CRL解析结果 */
    CmscbbCrlBundleInfo* pCrlOnDevice = NULL;  /* CRL解析结果 */
    CmscbbCrlPeriodStat crlStat = SCPS_MIX;  /* CRL比较结果 */
    CVB_BYTE* RootCert = NULL;    /* 证书汇总 */
    size_t RootCertLen;          /* 证书总字节数 */
    CVB_BYTE pbRootCert2[] = ROOT_CERT_PART2;   /* 证书局部数据 */
    CVB_BYTE pbRootG2Cert2[] = ROOT_G2_CERT_PART2; /* 获取G2 RSA_PSS根证书 */

    /* 组合根证书 */
    RootCertLen = sizeof(pbRootCert0) + sizeof(pbRootCert2);
    RootCert = (CVB_BYTE*)malloc(RootCertLen);
    if (RootCert == NULL) {
        OM_LOG_ERROR("Initialize root certificate failed.");
        return -1;
    }

    (CVB_VOID)memcpy_s(RootCert, RootCertLen, pbRootCert0, sizeof(pbRootCert0));
    (CVB_VOID)memcpy_s(RootCert + sizeof(pbRootCert0), RootCertLen - sizeof(pbRootCert0), pbRootCert2,
        sizeof(pbRootCert2));

    size_t rootCertG2Size = sizeof(pbRootG2Cert0) + sizeof(pbRootG2Cert2);
    CVB_BYTE *pbRootG2 = GetRootCerf(pbRootG2Cert0, sizeof(pbRootG2Cert0), pbRootG2Cert2, sizeof(pbRootG2Cert2));
    if (pbRootG2 == CVB_NULL) {
        OM_LOG_ERROR("Get root PSS certificate failed.");
        free(RootCert);
        RootCert = NULL;
        return -1;
    }

    if (GetCrlAndDecode(updateCrl, RootCert, RootCertLen, pbRootG2, rootCertG2Size,
        &vrf_ctx1, &pCrlToUpdate) != CVB_SUCCESS) {
        free(RootCert);
        free(pbRootG2);
        pbRootG2 = NULL;
        RootCert = NULL;
        return  -1;
    }

    if (GetCrlAndDecode(pCrlFileOnDevice, RootCert, RootCertLen, pbRootG2, rootCertG2Size,
        &vrf_ctx2, &pCrlOnDevice) != CVB_SUCCESS) {
        CmscbbCrlFree(vrf_ctx1, pCrlToUpdate);
        free(RootCert);
        free(pbRootG2);
        pbRootG2 = NULL;
        RootCert = NULL;
        return  -1;
    }

    /* 比较两个crl */
    if ((CmscbbCrlCompare(vrf_ctx2, pCrlToUpdate, pCrlOnDevice, &crlStat)) != CVB_SUCCESS) {
        CmscbbCrlFree(vrf_ctx1, pCrlToUpdate);
        CmscbbCrlFree(vrf_ctx2, pCrlOnDevice);
        CmscbbVrfCtxFree(vrf_ctx1);
        CmscbbVrfCtxFree(vrf_ctx2);
        free(RootCert);
        free(pbRootG2);
        pbRootG2 = NULL;
        RootCert = NULL;
        OM_LOG_ERROR("CmscbbCrlCompare fail.");
        return -1;
    }

    /* 保存crl比较的结果 */
    *stat = crlStat;

    /* 销毁资源 */
    CmscbbCrlFree(vrf_ctx1, pCrlToUpdate);
    CmscbbCrlFree(vrf_ctx2, pCrlOnDevice);
    CmscbbVrfCtxFree(vrf_ctx1);
    CmscbbVrfCtxFree(vrf_ctx2);
    free(RootCert);
    free(pbRootG2);
    pbRootG2 = NULL;
    RootCert = NULL;
    return 0;
}

static int CompareCrlFile(const char *updateCrl, const char *localCrl)
{
    CmscbbCrlPeriodStat stat;
    int ret;
    if (updateCrl == NULL || localCrl == NULL) {
        OM_LOG_ERROR("check input parameter fail!");
        return -1;
    }

    ret = DoCrlCompare(updateCrl, localCrl, &stat);
    if (ret != 0) {
        OM_LOG_ERROR("DoCrlCompare: return error code %d.", ret);
        return -1;
    }

    switch (stat) {
        case SCPS_SAME:
        case SCPS_OLD:
            OM_LOG_INFO("input CRL is same with or older than local, No need to update!");
            return 0;

        case SCPS_NEW:
            OM_LOG_INFO("input CRL is newer, update to local now!");
            if (CopyCrlToSavePath(updateCrl, localCrl) != 0) {
                return -1;
            }
            return 0;

        case SCPS_MIX:
            OM_LOG_INFO("can not compare input CRL, Not to update!");
            break;

        default:
            OM_LOG_INFO("unknown compare result, Not to update!");
            break;
    }

    return 0;
}

static int UpdateCrlFile(const char *updateCrl, char* localCrl)
{
    int ret;

    if (ChkUsrInputCrl(updateCrl) != 0) {
        OM_LOG_ERROR("ChkUsrInputCrl error!");
        return -1;
    }

    ret = GetLocalCrlFromUptCrl(updateCrl, localCrl);
    if (ret != 0) {
        OM_LOG_ERROR("input crl algorithm is wrong!");
        return -1;
    }

    ret = ChkSysLocalCrl(updateCrl, localCrl);
    if (ret == UPDATE_OK) {
        return 0;
    } else if (ret != 0) {
        OM_LOG_ERROR("ChkSysLocalCrl error!");
        return -1;
    }

    CmscbbCrlPeriodStat stat;
    ret = DoCrlCompare(updateCrl, updateCrl, &stat);
    if (ret != 0 || stat != SCPS_SAME) {
        OM_LOG_ERROR("software CRL is not available!");
        return -1;
    }

    ret = DoCrlCompare(localCrl, localCrl, &stat);
    if (ret != 0 || stat != SCPS_SAME) {
        OM_LOG_WARN("local CRL is not available, update to local now!");
        CopyCrlToSavePath(updateCrl, localCrl);
    }

    ret = CompareCrlFile(updateCrl, localCrl);
    if (ret != 0) {
        OM_LOG_WARN("update crl error, use software crl.");
        CopyCrlToSavePath(updateCrl, localCrl);
    }

    return 0;
}

static void FreeCtxAndPbroot(CMSCBB_VRF_CTX vrf_ctx, CVB_BYTE *pbRoot, CVB_BYTE *pbRootG2)
{
    if (vrf_ctx != CVB_NULL) {
        CmscbbVrfCtxFree(vrf_ctx);
        vrf_ctx = CVB_NULL;
    }

    if (pbRoot != CVB_NULL) {
        free(pbRoot);
        pbRoot = CVB_NULL;
    }

    if (pbRootG2 != CVB_NULL) {
        free(pbRootG2);
        pbRootG2 = CVB_NULL;
    }
}

static CMSCBB_ERROR_CODE AddRootCertFile(CMSCBB_VRF_CTX *vrf_ctx, CVB_BYTE **pbRoot, CVB_BYTE **pbRootG2)
{
    /* 获取RSA_PKCS1_V1_5根证书 */
    CVB_BYTE pbRootCert2[] = ROOT_CERT_PART2;
    size_t rootCertSize = sizeof(pbRootCert0) + sizeof(pbRootCert2);
    *pbRoot = GetRootCerf(pbRootCert0, sizeof(pbRootCert0), pbRootCert2, sizeof(pbRootCert2));
    if (*pbRoot == CVB_NULL) {
        OM_LOG_ERROR("Get root PKCS1_V1_5 certificate failed.");
        FreeCtxAndPbroot(*vrf_ctx, *pbRoot, *pbRootG2);
        return CMSCBB_ERR_SYS_MEM_ALLOC;
    }

    /* 添加RSA_PKCS1_V1_5根证书 */
    CMSCBB_ERROR_CODE ret = CmscbbVerifyAddCert(*vrf_ctx, (const CVB_BYTE *)*pbRoot, rootCertSize);
    if (ret != CVB_SUCCESS) {
        OM_LOG_ERROR("Add root PKCS1_V1_5 certificate failed.");
        FreeCtxAndPbroot(*vrf_ctx, *pbRoot, *pbRootG2);
        return ret;
    }

    /* 获取RSA_PSS根证书 */
    CVB_BYTE pbRootG2Cert2[] = ROOT_G2_CERT_PART2;
    size_t rootCertG2Size = sizeof(pbRootG2Cert0) + sizeof(pbRootG2Cert2);
    *pbRootG2 = GetRootCerf(pbRootG2Cert0, sizeof(pbRootG2Cert0), pbRootG2Cert2, sizeof(pbRootG2Cert2));
    if (*pbRootG2 == CVB_NULL) {
        OM_LOG_ERROR("Get root PSS certificate failed.");
        FreeCtxAndPbroot(*vrf_ctx, *pbRoot, *pbRootG2);
        return CMSCBB_ERR_SYS_MEM_ALLOC;
    }

    /* 添加RSA_PSS根证书 */
    ret = CmscbbVerifyAddCert(*vrf_ctx, (const CVB_BYTE *)*pbRootG2, rootCertG2Size);
    if (ret != CVB_SUCCESS) {
        OM_LOG_ERROR("Add root PSS certificate failed.");
        FreeCtxAndPbroot(*vrf_ctx, *pbRoot, *pbRootG2);
        return ret;
    }

    return CVB_SUCCESS;
}

static CMSCBB_ERROR_CODE verify_cms_file(const char* szSig, const char *szSrc, const char *szCrl)
{
    CMSCBB_VRF_CTX vrf_ctx = NULL;
    CMSCBB_ERROR_CODE ret;
    CmscbbCtxCreateParams createParams = { 0 };
    CVB_BYTE* pbRoot = CVB_NULL;    /* RSA_PKCS1_V1_5证书汇总 */
    CVB_BYTE *pbRootG2 = CVB_NULL;  /* RSA_PSS证书汇总  */
    CVB_INT32 result = 0;
    if (szSig == CVB_NULL || szSrc == CVB_NULL || szCrl == CVB_NULL) {
        OM_LOG_ERROR("input param is NULL.");
        return CMSCBB_ERR_CONTEXT_INVALID_PARAM;
    }
    createParams.st_size = sizeof(createParams);

    /* 创建验证上下文 */
    ret = CmscbbVerifyCreateCtx(&vrf_ctx, &createParams);
    if (ret != CVB_SUCCESS) {
        OM_LOG_ERROR("create verify context failed.");
        return ret;
    }
    /* 添加根证书 */
    ret = AddRootCertFile(&vrf_ctx, &pbRoot, &pbRootG2);
    if (ret != CVB_SUCCESS) {
        OM_LOG_ERROR("Add root certificate failed.");
        FreeCtxAndPbroot(vrf_ctx, pbRoot, pbRootG2);
        return ret;
    }
    /* 添加CRL */
    ret = CmscbbVerifyAddCrlFile(vrf_ctx, (CVB_CHAR*)szCrl);
    if (ret != CVB_SUCCESS) {
        OM_LOG_ERROR("Add CRL file %s failed.", (CVB_CHAR*)szCrl);
        FreeCtxAndPbroot(vrf_ctx, pbRoot, pbRootG2);
        return ret;
    }
    /* 在保持证书和crl不变的前提下可以重复调用验证过程验证多个签名 */
    ret = CmscbbVerifyDetachSignatureQuick(vrf_ctx, (CVB_CHAR*)szSrc, (CVB_CHAR*)szSig, &result);
    if (ret != CVB_SUCCESS) {
        OM_LOG_ERROR("verify signature error, code %08x.", ret);
        FreeCtxAndPbroot(vrf_ctx, pbRoot, pbRootG2);
        return ret;
    }
    if (result != CVB_TRUE) {
        OM_LOG_ERROR("verify signature not match.");
        ret =  CMSCBB_ERR_PKI_CMS_VERIFY_FAILED;
        FreeCtxAndPbroot(vrf_ctx, pbRoot, pbRootG2);
        return ret;
    }
    /* 销毁资源 */
    FreeCtxAndPbroot(vrf_ctx, pbRoot, pbRootG2);
    return CVB_SUCCESS;
}

static int CheckUpgradeFiles(const char *cmsPath, const char *crlPath, const char *tarPath)
{
    int ret;
    /* 校验CMS文件路径 */
    ret = check_file_path_valid(cmsPath);
    if (ret != 0) {
        OM_LOG_ERROR("cmsPath is invalid. error code:%d!", ret);
        return -1;
    }

    /* 校验CRL文件路径 */
    ret = check_file_path_valid(crlPath);
    if (ret != 0) {
        OM_LOG_ERROR("crlPath is invalid. error code:%d!", ret);
        return -1;
    }

    /* 校验tar文件路径 */
    ret = check_file_path_valid(tarPath);
    if (ret != 0) {
        OM_LOG_ERROR("tarPath is invalid. error code:%d!", ret);
        return -1;
    }

    return 0;
}


#ifndef  DT_REG
#define  DT_REG     8
#endif

int prepareUpgradeImageCms(const char *pathname_cms, const char *pathname_crl, const char *pathname_tar)
{
    char crl[MAX_FILEPATH_LENGTH] = {0};
    char cms[MAX_FILEPATH_LENGTH] = {0};
    char tar[MAX_FILEPATH_LENGTH] = {0};
    char localCrl[MAX_FILEPATH_LENGTH + 1] = {0};

    if (pathname_cms == NULL || pathname_crl == NULL || pathname_tar == NULL) {
        OM_LOG_ERROR("input pathname error");
        return -1;
    }

    if (strcpy_s(cms, sizeof(cms), pathname_cms) != 0) {
        OM_LOG_ERROR("get cms path error");
        return -1;
    }
    if (strcpy_s(crl, sizeof(crl), pathname_crl) != 0) {
        OM_LOG_ERROR("get crl path error");
        return -1;
    }
    if (strcpy_s(tar, sizeof(tar), pathname_tar) != 0) {
        OM_LOG_ERROR("get tar path error");
        return -1;
    }

    int ret = CheckUpgradeFiles(cms, crl, tar);
    if (ret != 0) {
        OM_LOG_ERROR("check upgrade files path error");
        return -1;
    }

    /* 更新crl */
    ret = UpdateCrlFile(crl, localCrl);
    if (ret != 0) {
        OM_LOG_ERROR("UpdateCrlFile failed(%d)", ret);
        return ret;
    }

    /* 验证 cms签名 */
    unsigned int cms_ret = verify_cms_file(cms, tar, localCrl);
    if (cms_ret != 0) {
        OM_LOG_ERROR("verify cms file failed, cms_ret=%u", cms_ret);
        return -1;
    }

    return ret;
}
